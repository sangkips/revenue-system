// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assessment.sql

package models

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteAssessment = `-- name: DeleteAssessment :exec
DELETE FROM assessments WHERE id = $1
`

func (q *Queries) DeleteAssessment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAssessment, id)
	return err
}

const deleteAssessmentItem = `-- name: DeleteAssessmentItem :exec
DELETE FROM assessment_items WHERE id = $1
`

func (q *Queries) DeleteAssessmentItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAssessmentItem, id)
	return err
}

const getAssessmentByID = `-- name: GetAssessmentByID :one
SELECT id, county_id, taxpayer_id, revenue_id, assessment_number, assessment_type,
       financial_year, base_amount, calculated_amount, total_amount, status, due_date,
       assessed_by, assessed_date, created_at, updated_at
FROM assessments
WHERE id = $1
`

func (q *Queries) GetAssessmentByID(ctx context.Context, id uuid.UUID) (Assessment, error) {
	row := q.db.QueryRowContext(ctx, getAssessmentByID, id)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.CountyID,
		&i.TaxpayerID,
		&i.RevenueID,
		&i.AssessmentNumber,
		&i.AssessmentType,
		&i.FinancialYear,
		&i.BaseAmount,
		&i.CalculatedAmount,
		&i.TotalAmount,
		&i.Status,
		&i.DueDate,
		&i.AssessedBy,
		&i.AssessedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAssessmentItemByID = `-- name: GetAssessmentItemByID :one
SELECT id, assessment_id, item_description, quantity, unit_amount, total_amount, created_at
FROM assessment_items
WHERE id = $1
`

func (q *Queries) GetAssessmentItemByID(ctx context.Context, id uuid.UUID) (AssessmentItem, error) {
	row := q.db.QueryRowContext(ctx, getAssessmentItemByID, id)
	var i AssessmentItem
	err := row.Scan(
		&i.ID,
		&i.AssessmentID,
		&i.ItemDescription,
		&i.Quantity,
		&i.UnitAmount,
		&i.TotalAmount,
		&i.CreatedAt,
	)
	return i, err
}

const insertAssessment = `-- name: InsertAssessment :one
INSERT INTO assessments (
    county_id, taxpayer_id, revenue_id, assessment_number, assessment_type,
    financial_year, base_amount, calculated_amount, total_amount,
    status, due_date, assessed_by, assessed_date
)
VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9,
    $10, $11, $12, $13
)
RETURNING id, county_id, taxpayer_id, revenue_id, assessment_number, assessment_type,
    financial_year, base_amount, calculated_amount, total_amount, status, due_date,
    assessed_by, assessed_date, created_at, updated_at
`

type InsertAssessmentParams struct {
	CountyID         int32         `json:"county_id"`
	TaxpayerID       uuid.UUID     `json:"taxpayer_id"`
	RevenueID        uuid.NullUUID `json:"revenue_id"`
	AssessmentNumber string        `json:"assessment_number"`
	AssessmentType   string        `json:"assessment_type"`
	FinancialYear    string        `json:"financial_year"`
	BaseAmount       string        `json:"base_amount"`
	CalculatedAmount string        `json:"calculated_amount"`
	TotalAmount      string        `json:"total_amount"`
	Status           string        `json:"status"`
	DueDate          time.Time     `json:"due_date"`
	AssessedBy       uuid.NullUUID `json:"assessed_by"`
	AssessedDate     time.Time     `json:"assessed_date"`
}

// internal/domains/assessment/queries/assessment.sql
func (q *Queries) InsertAssessment(ctx context.Context, arg InsertAssessmentParams) (Assessment, error) {
	row := q.db.QueryRowContext(ctx, insertAssessment,
		arg.CountyID,
		arg.TaxpayerID,
		arg.RevenueID,
		arg.AssessmentNumber,
		arg.AssessmentType,
		arg.FinancialYear,
		arg.BaseAmount,
		arg.CalculatedAmount,
		arg.TotalAmount,
		arg.Status,
		arg.DueDate,
		arg.AssessedBy,
		arg.AssessedDate,
	)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.CountyID,
		&i.TaxpayerID,
		&i.RevenueID,
		&i.AssessmentNumber,
		&i.AssessmentType,
		&i.FinancialYear,
		&i.BaseAmount,
		&i.CalculatedAmount,
		&i.TotalAmount,
		&i.Status,
		&i.DueDate,
		&i.AssessedBy,
		&i.AssessedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertAssessmentItem = `-- name: InsertAssessmentItem :one
INSERT INTO assessment_items (
    assessment_id, item_description, quantity, unit_amount, total_amount
)
VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, assessment_id, item_description, quantity, unit_amount, total_amount, created_at
`

type InsertAssessmentItemParams struct {
	AssessmentID    uuid.UUID      `json:"assessment_id"`
	ItemDescription string         `json:"item_description"`
	Quantity        sql.NullString `json:"quantity"`
	UnitAmount      string         `json:"unit_amount"`
	TotalAmount     string         `json:"total_amount"`
}

// Assessment Items Queries
func (q *Queries) InsertAssessmentItem(ctx context.Context, arg InsertAssessmentItemParams) (AssessmentItem, error) {
	row := q.db.QueryRowContext(ctx, insertAssessmentItem,
		arg.AssessmentID,
		arg.ItemDescription,
		arg.Quantity,
		arg.UnitAmount,
		arg.TotalAmount,
	)
	var i AssessmentItem
	err := row.Scan(
		&i.ID,
		&i.AssessmentID,
		&i.ItemDescription,
		&i.Quantity,
		&i.UnitAmount,
		&i.TotalAmount,
		&i.CreatedAt,
	)
	return i, err
}

const listAssessmentItems = `-- name: ListAssessmentItems :many
SELECT id, assessment_id, item_description, quantity, unit_amount, total_amount, created_at
FROM assessment_items
WHERE assessment_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListAssessmentItems(ctx context.Context, assessmentID uuid.UUID) ([]AssessmentItem, error) {
	rows, err := q.db.QueryContext(ctx, listAssessmentItems, assessmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssessmentItem
	for rows.Next() {
		var i AssessmentItem
		if err := rows.Scan(
			&i.ID,
			&i.AssessmentID,
			&i.ItemDescription,
			&i.Quantity,
			&i.UnitAmount,
			&i.TotalAmount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssessments = `-- name: ListAssessments :many
SELECT id, county_id, taxpayer_id, revenue_id, assessment_number, assessment_type,
       financial_year, base_amount, calculated_amount, total_amount, status, due_date,
       assessed_by, assessed_date, created_at, updated_at
FROM assessments
WHERE county_id = $3
ORDER BY assessed_date DESC
LIMIT $1 OFFSET $2
`

type ListAssessmentsParams struct {
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
	CountyID int32 `json:"county_id"`
}

func (q *Queries) ListAssessments(ctx context.Context, arg ListAssessmentsParams) ([]Assessment, error) {
	rows, err := q.db.QueryContext(ctx, listAssessments, arg.Limit, arg.Offset, arg.CountyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assessment
	for rows.Next() {
		var i Assessment
		if err := rows.Scan(
			&i.ID,
			&i.CountyID,
			&i.TaxpayerID,
			&i.RevenueID,
			&i.AssessmentNumber,
			&i.AssessmentType,
			&i.FinancialYear,
			&i.BaseAmount,
			&i.CalculatedAmount,
			&i.TotalAmount,
			&i.Status,
			&i.DueDate,
			&i.AssessedBy,
			&i.AssessedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssessment = `-- name: UpdateAssessment :one
UPDATE assessments
SET
    base_amount = COALESCE($1, base_amount),
    calculated_amount = COALESCE($2, calculated_amount),
    total_amount = COALESCE($3, total_amount),
    status = COALESCE($4, status),
    due_date = COALESCE($5, due_date),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $6
RETURNING id, county_id, taxpayer_id, revenue_id, assessment_number, assessment_type,
    financial_year, base_amount, calculated_amount, total_amount, status, due_date,
    assessed_by, assessed_date, created_at, updated_at
`

type UpdateAssessmentParams struct {
	BaseAmount       string    `json:"base_amount"`
	CalculatedAmount string    `json:"calculated_amount"`
	TotalAmount      string    `json:"total_amount"`
	Status           string    `json:"status"`
	DueDate          time.Time `json:"due_date"`
	ID               uuid.UUID `json:"id"`
}

func (q *Queries) UpdateAssessment(ctx context.Context, arg UpdateAssessmentParams) (Assessment, error) {
	row := q.db.QueryRowContext(ctx, updateAssessment,
		arg.BaseAmount,
		arg.CalculatedAmount,
		arg.TotalAmount,
		arg.Status,
		arg.DueDate,
		arg.ID,
	)
	var i Assessment
	err := row.Scan(
		&i.ID,
		&i.CountyID,
		&i.TaxpayerID,
		&i.RevenueID,
		&i.AssessmentNumber,
		&i.AssessmentType,
		&i.FinancialYear,
		&i.BaseAmount,
		&i.CalculatedAmount,
		&i.TotalAmount,
		&i.Status,
		&i.DueDate,
		&i.AssessedBy,
		&i.AssessedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
