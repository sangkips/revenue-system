// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package models

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePayment, id)
	return err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, county_id, taxpayer_id, assessment_id, payment_number, amount, payment_method,
       payment_channel, external_transaction_id, payer_phone_number, payer_name,
       payment_date, status, collected_by, created_at, updated_at
FROM payments
WHERE id = $1
`

func (q *Queries) GetPaymentByID(ctx context.Context, id uuid.UUID) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.CountyID,
		&i.TaxpayerID,
		&i.AssessmentID,
		&i.PaymentNumber,
		&i.Amount,
		&i.PaymentMethod,
		&i.PaymentChannel,
		&i.ExternalTransactionID,
		&i.PayerPhoneNumber,
		&i.PayerName,
		&i.PaymentDate,
		&i.Status,
		&i.CollectedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertPayment = `-- name: InsertPayment :one
INSERT INTO payments (
    county_id, taxpayer_id, assessment_id, payment_number, amount, payment_method,
    payment_channel, external_transaction_id, payer_phone_number, payer_name,
    status, collected_by
)
VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12
)
RETURNING id, county_id, taxpayer_id, assessment_id, payment_number, amount, payment_method,
    payment_channel, external_transaction_id, payer_phone_number, payer_name,
    payment_date, status, collected_by, created_at, updated_at
`

type InsertPaymentParams struct {
	CountyID              int32          `json:"county_id"`
	TaxpayerID            uuid.UUID      `json:"taxpayer_id"`
	AssessmentID          uuid.NullUUID  `json:"assessment_id"`
	PaymentNumber         string         `json:"payment_number"`
	Amount                string         `json:"amount"`
	PaymentMethod         string         `json:"payment_method"`
	PaymentChannel        sql.NullString `json:"payment_channel"`
	ExternalTransactionID sql.NullString `json:"external_transaction_id"`
	PayerPhoneNumber      sql.NullString `json:"payer_phone_number"`
	PayerName             sql.NullString `json:"payer_name"`
	Status                string         `json:"status"`
	CollectedBy           uuid.NullUUID  `json:"collected_by"`
}

// internal/domains/payments/queries/payments.sql
func (q *Queries) InsertPayment(ctx context.Context, arg InsertPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, insertPayment,
		arg.CountyID,
		arg.TaxpayerID,
		arg.AssessmentID,
		arg.PaymentNumber,
		arg.Amount,
		arg.PaymentMethod,
		arg.PaymentChannel,
		arg.ExternalTransactionID,
		arg.PayerPhoneNumber,
		arg.PayerName,
		arg.Status,
		arg.CollectedBy,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.CountyID,
		&i.TaxpayerID,
		&i.AssessmentID,
		&i.PaymentNumber,
		&i.Amount,
		&i.PaymentMethod,
		&i.PaymentChannel,
		&i.ExternalTransactionID,
		&i.PayerPhoneNumber,
		&i.PayerName,
		&i.PaymentDate,
		&i.Status,
		&i.CollectedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPayments = `-- name: ListPayments :many
SELECT id, county_id, taxpayer_id, assessment_id, payment_number, amount, payment_method,
       payment_channel, external_transaction_id, payer_phone_number, payer_name,
       payment_date, status, collected_by, created_at, updated_at
FROM payments
WHERE county_id = $3
ORDER BY payment_date DESC
LIMIT $1 OFFSET $2
`

type ListPaymentsParams struct {
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
	CountyID int32 `json:"county_id"`
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPayments, arg.Limit, arg.Offset, arg.CountyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.CountyID,
			&i.TaxpayerID,
			&i.AssessmentID,
			&i.PaymentNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.PaymentChannel,
			&i.ExternalTransactionID,
			&i.PayerPhoneNumber,
			&i.PayerName,
			&i.PaymentDate,
			&i.Status,
			&i.CollectedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByRevenueID = `-- name: ListPaymentsByRevenueID :many
SELECT id, county_id, taxpayer_id, assessment_id, payment_number, amount, payment_method,
       payment_channel, external_transaction_id, payer_phone_number, payer_name,
       payment_date, status, collected_by, created_at, updated_at
FROM payments
WHERE assessment_id = $1
ORDER BY payment_date DESC
`

func (q *Queries) ListPaymentsByRevenueID(ctx context.Context, assessmentID uuid.NullUUID) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsByRevenueID, assessmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.CountyID,
			&i.TaxpayerID,
			&i.AssessmentID,
			&i.PaymentNumber,
			&i.Amount,
			&i.PaymentMethod,
			&i.PaymentChannel,
			&i.ExternalTransactionID,
			&i.PayerPhoneNumber,
			&i.PayerName,
			&i.PaymentDate,
			&i.Status,
			&i.CollectedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET 
    amount = COALESCE($1, amount),
    payment_method = COALESCE($2, payment_method),
    payment_channel = COALESCE($3, payment_channel),
    external_transaction_id = COALESCE($4, external_transaction_id),
    payer_phone_number = COALESCE($5, payer_phone_number),
    payer_name = COALESCE($6, payer_name),
    status = COALESCE($7, status),
    collected_by = COALESCE($8, collected_by),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $9
RETURNING id, county_id, taxpayer_id, assessment_id, payment_number, amount, payment_method,
    payment_channel, external_transaction_id, payer_phone_number, payer_name,
    payment_date, status, collected_by, created_at, updated_at
`

type UpdatePaymentParams struct {
	Amount                string         `json:"amount"`
	PaymentMethod         string         `json:"payment_method"`
	PaymentChannel        sql.NullString `json:"payment_channel"`
	ExternalTransactionID sql.NullString `json:"external_transaction_id"`
	PayerPhoneNumber      sql.NullString `json:"payer_phone_number"`
	PayerName             sql.NullString `json:"payer_name"`
	Status                string         `json:"status"`
	CollectedBy           uuid.NullUUID  `json:"collected_by"`
	ID                    uuid.UUID      `json:"id"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, updatePayment,
		arg.Amount,
		arg.PaymentMethod,
		arg.PaymentChannel,
		arg.ExternalTransactionID,
		arg.PayerPhoneNumber,
		arg.PayerName,
		arg.Status,
		arg.CollectedBy,
		arg.ID,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.CountyID,
		&i.TaxpayerID,
		&i.AssessmentID,
		&i.PaymentNumber,
		&i.Amount,
		&i.PaymentMethod,
		&i.PaymentChannel,
		&i.ExternalTransactionID,
		&i.PayerPhoneNumber,
		&i.PayerName,
		&i.PaymentDate,
		&i.Status,
		&i.CollectedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
